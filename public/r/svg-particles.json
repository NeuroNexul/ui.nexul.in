{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "svg-particles",
  "title": "SVG Particles",
  "description": "An interactive canvas particle effect that renders SVG paths as animated particles with mouse interaction.",
  "dependencies": [
    "@/lib/utils"
  ],
  "files": [
    {
      "path": "registry/art/svg-particles/svg-particles.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ntype Props = React.HTMLAttributes<HTMLDivElement> & {\r\n  /** SVG path string(s) (d attribute) to render as particles. Can be a single path or an array of paths. */\r\n  svgPath: string | string[];\r\n  /** Original viewBox width of the SVG path */\r\n  viewBoxWidth?: number;\r\n  /** Original viewBox height of the SVG path */\r\n  viewBoxHeight?: number;\r\n  /** Height of the logo in pixels (desktop) */\r\n  logoHeight?: number;\r\n  /** Height of the logo in pixels (mobile) */\r\n  mobileLogoHeight?: number;\r\n  /** Color of particles when scattered by mouse interaction */\r\n  scatteredColor?: string;\r\n  /** Base color of particles */\r\n  particleColor?: string;\r\n  /** Background color of the canvas */\r\n  backgroundColor?: string;\r\n  /** Whether to fill or stroke the SVG path */\r\n  pathStyle?: \"fill\" | \"stroke\";\r\n  /** Stroke width when using stroke style (in viewBox units) */\r\n  strokeWidth?: number;\r\n  /** Line join style for stroke corners */\r\n  lineJoin?: CanvasLineJoin;\r\n  /** Line cap style for stroke endpoints */\r\n  lineCap?: CanvasLineCap;\r\n  /** Force multiplier for particle scattering */\r\n  forceMu?: number;\r\n  /** Interaction mode: \"scatter\" pushes particles while mouse is near, \"spill\" gives particles velocity that decays over time */\r\n  interactionMode?: \"scatter\" | \"spill\";\r\n  /** How quickly particles return to their base position (0-1, lower = slower) */\r\n  returnSpeed?: number;\r\n  /** Friction applied to particle velocity in spill mode (0-1, lower = more friction) */\r\n  friction?: number;\r\n  /** Whether to enable particle death */\r\n  enableParticleDeath?: boolean;\r\n};\r\n\r\nexport default function SVGParticles({\r\n  svgPath,\r\n  viewBoxWidth = 100,\r\n  viewBoxHeight = 100,\r\n  logoHeight: desktopLogoHeight = 120,\r\n  mobileLogoHeight = 60,\r\n  scatteredColor = \"#00DCFF\",\r\n  particleColor = \"white\",\r\n  backgroundColor = \"black\",\r\n  pathStyle = \"fill\",\r\n  strokeWidth = 1,\r\n  lineJoin = \"miter\",\r\n  lineCap = \"butt\",\r\n  forceMu = 1,\r\n  interactionMode = \"scatter\",\r\n  returnSpeed = 0.1,\r\n  friction = 0.95,\r\n  enableParticleDeath = true,\r\n  className,\r\n  ...props\r\n}: Props) {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const mousePositionRef = useRef({ x: 0, y: 0 });\r\n  const isTouchingRef = useRef(false);\r\n  const [isMobile, setIsMobile] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    const canvas = canvasRef.current;\r\n    if (!container || !canvas) return;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) return;\r\n\r\n    const updateCanvasSize = () => {\r\n      const rect = container.getBoundingClientRect();\r\n      canvas.width = rect.width;\r\n      canvas.height = rect.height;\r\n      setIsMobile(rect.width < 768);\r\n    };\r\n\r\n    updateCanvasSize();\r\n\r\n    let particles: {\r\n      x: number;\r\n      y: number;\r\n      baseX: number;\r\n      baseY: number;\r\n      size: number;\r\n      life: number;\r\n      vx: number;\r\n      vy: number;\r\n    }[] = [];\r\n\r\n    let textImageData: ImageData | null = null;\r\n\r\n    function createTextImage() {\r\n      if (!ctx || !canvas) return 0;\r\n\r\n      ctx.fillStyle = particleColor;\r\n      ctx.save();\r\n\r\n      const logoHeight = isMobile ? mobileLogoHeight : desktopLogoHeight;\r\n      const scale = logoHeight / viewBoxHeight;\r\n      const logoWidth = viewBoxWidth * scale;\r\n\r\n      ctx.translate(\r\n        canvas.width / 2 - logoWidth / 2,\r\n        canvas.height / 2 - logoHeight / 2\r\n      );\r\n\r\n      ctx.scale(scale, scale);\r\n\r\n      // Support both single path and array of paths\r\n      const paths = Array.isArray(svgPath) ? svgPath : [svgPath];\r\n      for (const pathStr of paths) {\r\n        const path = new Path2D(pathStr);\r\n        if (pathStyle === \"stroke\") {\r\n          ctx.strokeStyle = particleColor;\r\n          ctx.lineWidth = strokeWidth;\r\n          ctx.lineJoin = lineJoin;\r\n          ctx.lineCap = lineCap;\r\n          ctx.stroke(path);\r\n        } else {\r\n          ctx.fill(path);\r\n        }\r\n      }\r\n\r\n      ctx.restore();\r\n\r\n      textImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      return scale;\r\n    }\r\n\r\n    function createParticle(scale: number) {\r\n      if (!ctx || !canvas || !textImageData) return null;\r\n\r\n      const data = textImageData.data;\r\n\r\n      for (let attempt = 0; attempt < 100; attempt++) {\r\n        const x = Math.floor(Math.random() * canvas.width);\r\n        const y = Math.floor(Math.random() * canvas.height);\r\n\r\n        if (data[(y * canvas.width + x) * 4 + 3] > 128) {\r\n          return {\r\n            x: x,\r\n            y: y,\r\n            baseX: x,\r\n            baseY: y,\r\n            size: Math.random() * 1 + 0.5,\r\n            life: Math.random() * 100 + 50,\r\n            vx: 0,\r\n            vy: 0,\r\n          };\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    function createInitialParticles(scale: number) {\r\n      if (!ctx || !canvas) return;\r\n\r\n      const baseParticleCount = 7000;\r\n      const particleCount = Math.floor(\r\n        baseParticleCount *\r\n          Math.sqrt((canvas.width * canvas.height) / (1920 * 1080))\r\n      );\r\n      for (let i = 0; i < particleCount; i++) {\r\n        const particle = createParticle(scale);\r\n        if (particle) particles.push(particle);\r\n      }\r\n    }\r\n\r\n    let animationFrameId: number;\r\n\r\n    function animate(scale: number) {\r\n      if (!ctx || !canvas) return;\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n      ctx.fillStyle = backgroundColor;\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n      const { x: mouseX, y: mouseY } = mousePositionRef.current;\r\n      const maxDistance = 240;\r\n\r\n      for (let i = 0; i < particles.length; i++) {\r\n        const p = particles[i];\r\n        const dx = mouseX - p.x;\r\n        const dy = mouseY - p.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        const isInteracting =\r\n          distance < maxDistance &&\r\n          (isTouchingRef.current || !(\"ontouchstart\" in window));\r\n\r\n        if (interactionMode === \"spill\") {\r\n          // Spill mode: add velocity when mouse is near, particles drift and return slowly\r\n          if (isInteracting) {\r\n            const force = (forceMu * (maxDistance - distance)) / maxDistance;\r\n            const angle = Math.atan2(dy, dx);\r\n            p.vx -= Math.cos(angle) * force * 2;\r\n            p.vy -= Math.sin(angle) * force * 2;\r\n          }\r\n\r\n          // Apply velocity\r\n          p.x += p.vx;\r\n          p.y += p.vy;\r\n\r\n          // Apply friction to slow down\r\n          p.vx *= friction;\r\n          p.vy *= friction;\r\n\r\n          // Slowly return to base position\r\n          const returnDx = p.baseX - p.x;\r\n          const returnDy = p.baseY - p.y;\r\n          p.vx += returnDx * returnSpeed * 0.1;\r\n          p.vy += returnDy * returnSpeed * 0.1;\r\n\r\n          // Color based on distance from base position\r\n          const distFromBase = Math.sqrt(\r\n            returnDx * returnDx + returnDy * returnDy\r\n          );\r\n          if (distFromBase > 2) {\r\n            ctx.fillStyle = scatteredColor;\r\n          } else {\r\n            ctx.fillStyle = particleColor;\r\n          }\r\n        } else {\r\n          // Scatter mode: particles move away while mouse is near, snap back when it leaves\r\n          if (isInteracting) {\r\n            const force = (forceMu * (maxDistance - distance)) / maxDistance;\r\n            const angle = Math.atan2(dy, dx);\r\n            const moveX = Math.cos(angle) * force * 60;\r\n            const moveY = Math.sin(angle) * force * 60;\r\n            p.x = p.baseX - moveX;\r\n            p.y = p.baseY - moveY;\r\n\r\n            ctx.fillStyle = scatteredColor;\r\n          } else {\r\n            p.x += (p.baseX - p.x) * returnSpeed;\r\n            p.y += (p.baseY - p.y) * returnSpeed;\r\n            ctx.fillStyle = particleColor;\r\n          }\r\n        }\r\n\r\n        ctx.fillRect(p.x, p.y, p.size, p.size);\r\n\r\n        if (enableParticleDeath) p.life--;\r\n        if (p.life <= 0) {\r\n          const newParticle = createParticle(scale);\r\n          if (newParticle) {\r\n            particles[i] = newParticle;\r\n          } else {\r\n            particles.splice(i, 1);\r\n            i--;\r\n          }\r\n        }\r\n      }\r\n\r\n      const baseParticleCount = 7000;\r\n      const targetParticleCount = Math.floor(\r\n        baseParticleCount *\r\n          Math.sqrt((canvas.width * canvas.height) / (1920 * 1080))\r\n      );\r\n      while (particles.length < targetParticleCount) {\r\n        const newParticle = createParticle(scale);\r\n        if (newParticle) particles.push(newParticle);\r\n      }\r\n\r\n      animationFrameId = requestAnimationFrame(() => animate(scale));\r\n    }\r\n\r\n    const scale = createTextImage();\r\n    createInitialParticles(scale);\r\n    animate(scale);\r\n\r\n    const handleResize = () => {\r\n      updateCanvasSize();\r\n      const newScale = createTextImage();\r\n      particles = [];\r\n      createInitialParticles(newScale);\r\n    };\r\n\r\n    const resizeObserver = new ResizeObserver(handleResize);\r\n    resizeObserver.observe(container);\r\n\r\n    const handleMove = (x: number, y: number) => {\r\n      const rect = canvas.getBoundingClientRect();\r\n      mousePositionRef.current = { x: x - rect.left, y: y - rect.top };\r\n    };\r\n\r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      handleMove(e.clientX, e.clientY);\r\n    };\r\n\r\n    const handleTouchMove = (e: TouchEvent) => {\r\n      if (e.touches.length > 0) {\r\n        e.preventDefault();\r\n        handleMove(e.touches[0].clientX, e.touches[0].clientY);\r\n      }\r\n    };\r\n\r\n    const handleTouchStart = () => {\r\n      isTouchingRef.current = true;\r\n    };\r\n\r\n    const handleTouchEnd = () => {\r\n      isTouchingRef.current = false;\r\n      mousePositionRef.current = { x: 0, y: 0 };\r\n    };\r\n\r\n    const handleMouseLeave = () => {\r\n      if (!(\"ontouchstart\" in window)) {\r\n        mousePositionRef.current = { x: 0, y: 0 };\r\n      }\r\n    };\r\n\r\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\r\n    canvas.addEventListener(\"touchmove\", handleTouchMove, { passive: false });\r\n    canvas.addEventListener(\"mouseleave\", handleMouseLeave);\r\n    canvas.addEventListener(\"touchstart\", handleTouchStart);\r\n    canvas.addEventListener(\"touchend\", handleTouchEnd);\r\n\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n      canvas.removeEventListener(\"mousemove\", handleMouseMove);\r\n      canvas.removeEventListener(\"touchmove\", handleTouchMove);\r\n      canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\r\n      canvas.removeEventListener(\"touchstart\", handleTouchStart);\r\n      canvas.removeEventListener(\"touchend\", handleTouchEnd);\r\n      cancelAnimationFrame(animationFrameId);\r\n    };\r\n  }, [\r\n    svgPath,\r\n    isMobile,\r\n    viewBoxWidth,\r\n    viewBoxHeight,\r\n    desktopLogoHeight,\r\n    mobileLogoHeight,\r\n    scatteredColor,\r\n    particleColor,\r\n    backgroundColor,\r\n    pathStyle,\r\n    strokeWidth,\r\n    lineJoin,\r\n    lineCap,\r\n    forceMu,\r\n    interactionMode,\r\n    returnSpeed,\r\n    friction,\r\n    enableParticleDeath,\r\n  ]);\r\n\r\n  return (\r\n    <div ref={containerRef} className={cn(\"relative\", className)} {...props}>\r\n      <canvas\r\n        ref={canvasRef}\r\n        className=\"w-full h-full absolute top-0 left-0 touch-none\"\r\n        aria-label=\"Interactive particle effect\"\r\n      />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "components/ui/svg-particles.tsx"
    }
  ],
  "type": "registry:component"
}