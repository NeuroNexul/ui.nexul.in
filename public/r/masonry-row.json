{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "masonry-row",
  "title": "Masonry Row Grid Layout",
  "description": "A responsive masonry grid layout that arranges items of different sizes in rows with varying heights.",
  "files": [
    {
      "path": "registry/layouts/masonry/masonry-row.tsx",
      "content": "\"use client\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport React from \"react\";\r\nimport {\r\n  calculateJustifiedMasonryLayout,\r\n  calculateNaiveMasonryLayout,\r\n} from \"./calculate-masonry-row\";\r\nimport { mergeRefs } from \"@/lib/merge-refs\";\r\n\r\nexport type GridItemProps = {\r\n  /** Original width of the grid item */\r\n  width: number;\r\n  /** Original height of the grid item */\r\n  height: number;\r\n\r\n  // Additional properties can be added as needed\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  [key: string]: any;\r\n};\r\n\r\nexport type Measures = {\r\n  /** Calculated width of the grid item */\r\n  width: number;\r\n  /** Calculated height of the grid item */\r\n  height: number;\r\n  /** Calculated top position of the grid item */\r\n  top: number;\r\n  /** Calculated left position of the grid item */\r\n  left: number;\r\n\r\n  /** Row number of the grid item in the row (0-based index) */\r\n  index: number;\r\n  /** Row number of the grid item (1-based index) */\r\n  rowNo: number;\r\n  /** Total items in the row */\r\n  totalItemsInRow: number;\r\n};\r\n\r\nexport type Props = {\r\n  /** Container props for the masonry grid container */\r\n  containerProps?: React.HTMLAttributes<HTMLDivElement>;\r\n  /** Item props for each masonry grid item */\r\n  itemProps?: React.HTMLAttributes<HTMLDivElement>;\r\n  /** Gap between grid items */\r\n  gap?: number;\r\n  /** Target height for each grid item; default is 300 */\r\n  targetHeight?: number;\r\n  /** Scale factor for resizing grid items; default is 0.1 */\r\n  scaleFactor?: number;\r\n  /** Layout type: \"naive\" or \"justified\"; default is \"naive\" */\r\n  layout?: \"naive\" | \"justified\";\r\n  /** Array of grid items to be displayed */\r\n  items?: GridItemProps[];\r\n  /** Function to render each grid item */\r\n  renderItem?: (\r\n    /** Props of the grid item to be rendered */\r\n    item: GridItemProps,\r\n    /** Index of the grid item in the array */\r\n    index: number,\r\n    /** Calculated measures for the grid item */\r\n    measures: Measures\r\n  ) => React.ReactNode;\r\n};\r\n\r\nconst MasonryRowGrid = React.forwardRef<HTMLDivElement, Props>(\r\n  (\r\n    {\r\n      containerProps: { className, style, ...containerProps } = {},\r\n      itemProps: {\r\n        className: itemClassName,\r\n        style: itemStyle,\r\n        ...itemProps\r\n      } = {},\r\n      gap = 8,\r\n      targetHeight = 300,\r\n      scaleFactor = 0.1,\r\n      layout: layoutType = \"naive\",\r\n      items = [],\r\n      renderItem,\r\n    }: Props,\r\n    ref\r\n  ) => {\r\n    const [viewportWidth, setViewportWidth] = React.useState<number>(0);\r\n    const containerRef = React.useRef<HTMLDivElement | null>(null);\r\n\r\n    const [measures, totalHeight, rowCount] = React.useMemo(\r\n      () =>\r\n        layoutType === \"naive\"\r\n          ? calculateNaiveMasonryLayout({\r\n              viewportWidth,\r\n              items,\r\n              targetHeight,\r\n              scaleFactor,\r\n            })\r\n          : calculateJustifiedMasonryLayout({\r\n              viewportWidth,\r\n              items,\r\n              targetHeight,\r\n              scaleFactor,\r\n            }),\r\n      [layoutType, viewportWidth, items, targetHeight, scaleFactor]\r\n    );\r\n\r\n    React.useLayoutEffect(() => {\r\n      if (!containerRef.current || containerRef.current === null) return; // Return if the container is not found\r\n      let animationFrameID: number | null = null; // Initialize animation frame ID\r\n\r\n      const resizeObserver = new ResizeObserver((entries) => {\r\n        const newWidth = entries[0].contentRect.width; // This gives the actual width of the inside of the container\r\n        if (animationFrameID) cancelAnimationFrame(animationFrameID); // Cancel the previous animation frame\r\n\r\n        animationFrameID = requestAnimationFrame(() => {\r\n          setViewportWidth(newWidth); // Update the viewport width based on the resize observer\r\n        });\r\n      });\r\n      resizeObserver.observe(containerRef.current); // Observe the container for changes\r\n      return () => {\r\n        resizeObserver.disconnect(); // Cleanup the observer on unmount\r\n        if (animationFrameID) cancelAnimationFrame(animationFrameID); // Cancel the animation frame on unmount\r\n      };\r\n    }, [containerRef, gap, items, targetHeight, scaleFactor]);\r\n\r\n    return (\r\n      <div\r\n        ref={mergeRefs(containerRef, ref)}\r\n        className={cn(\"relative\", className)}\r\n        style={{\r\n          height: totalHeight,\r\n          ...style,\r\n        }}\r\n        {...containerProps}\r\n      >\r\n        {items.map((item, index) => {\r\n          const measure = measures[index];\r\n\r\n          return (\r\n            <div\r\n              key={index}\r\n              className={cn(\"absolute\", itemClassName)}\r\n              style={{\r\n                top: measure.top,\r\n                left: measure.left,\r\n                width: measure.width,\r\n                height: measure.height,\r\n\r\n                paddingTop: measure.rowNo === 1 ? gap : gap / 2,\r\n                paddingBottom: measure.rowNo === rowCount ? gap : gap / 2,\r\n                paddingLeft: measure.index === 0 ? gap : gap / 2,\r\n                paddingRight:\r\n                  measure.index === measure.totalItemsInRow - 1 ? gap : gap / 2,\r\n\r\n                ...itemStyle,\r\n              }}\r\n              {...itemProps}\r\n            >\r\n              {renderItem ? renderItem(item, index, measure) : null}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n);\r\nMasonryRowGrid.displayName = \"MasonryRowGrid\";\r\n\r\nexport { MasonryRowGrid };\r\n",
      "type": "registry:component",
      "target": "components/ui/masonry/masonry-row.tsx"
    },
    {
      "path": "registry/layouts/masonry/calculate-masonry-row.ts",
      "content": "import { GridItemProps, Measures } from \"./masonry-row\";\r\n\r\n/**\r\n * Calculates the masonry layout for a set of items within a given viewport width.\r\n * @param viewportWidth - The width of the container in which the items will be laid out.\r\n * @param items - An array of items to be laid out, each with width and height properties.\r\n * @param targetHeight - The desired height for each row in the layout.\r\n * @param scaleFactor - A factor to allow rows to deviate from the target height.\r\n *\r\n * @returns [Measures[], totalHeight, rowCount]\r\n */\r\nexport function calculateNaiveMasonryLayout({\r\n  viewportWidth,\r\n  items,\r\n  targetHeight,\r\n  scaleFactor = 0.1,\r\n}: {\r\n  viewportWidth: number;\r\n  items: GridItemProps[];\r\n  targetHeight: number;\r\n  scaleFactor?: number;\r\n}) {\r\n\r\n  const max_height = targetHeight * (1 + scaleFactor);\r\n\r\n  let rows: Measures[] = [];\r\n  let row: Measures[] = [];\r\n  let currentWidth = 0;\r\n  let totalHeight = 0; // Initialize total height\r\n  let rowNumber = 1; // Initialize row number\r\n\r\n  function finalizeRow() {\r\n    // Calculate the height of the row based on the width and max height\r\n    const height =\r\n      viewportWidth < currentWidth\r\n        ? (viewportWidth / currentWidth) * max_height\r\n        : max_height;\r\n\r\n    let left = 0;\r\n    for (let i = 0; i < row.length; i++) {\r\n      const item = row[i];\r\n      const width = (height / item.height) * item.width;\r\n\r\n      row[i].width = width;\r\n      row[i].height = height;\r\n      row[i].top = totalHeight;\r\n      row[i].left = left;\r\n\r\n      row[i].index = i; // Update index in the row\r\n      row[i].totalItemsInRow = row.length; // Update total images in the row\r\n      left += width;\r\n    }\r\n\r\n    rows = rows.concat(row);\r\n    totalHeight += height;\r\n    row = [];\r\n    currentWidth = 0;\r\n    rowNumber += 1; // Increment row number\r\n  }\r\n\r\n  items.forEach((item) => {\r\n    row.push({\r\n      width: item.width,\r\n      height: item.height,\r\n      top: 0,\r\n      left: 0,\r\n\r\n      index: 0, // Placeholder, will be updated while finalizing\r\n      rowNo: rowNumber,\r\n      totalItemsInRow: 0, // Placeholder, will be updated while finalizing\r\n    });\r\n    currentWidth += (max_height / item.height) * item.width;\r\n\r\n    // If current width exceeds viewport, finalize the row\r\n    if (currentWidth >= viewportWidth) finalizeRow();\r\n  });\r\n\r\n  if (row.length > 0) finalizeRow();\r\n\r\n  return [rows, totalHeight, rowNumber] as const;\r\n}\r\n\r\n/**\r\n * Calculates the masonry layout for a set of items within a given viewport width.\r\n * @param viewportWidth - The width of the container in which the items will be laid out.\r\n * @param items - An array of items to be laid out, each with width and height properties.\r\n * @param targetHeight - The desired height for each row in the layout.\r\n * @param scaleFactor - A factor to allow rows to deviate from the target height.\r\n *\r\n * @returns [Measures[], totalHeight, rowCount]\r\n */\r\nexport function calculateJustifiedMasonryLayout({\r\n  viewportWidth,\r\n  items,\r\n  targetHeight,\r\n  scaleFactor = 0.1,\r\n}: {\r\n  viewportWidth: number;\r\n  items: GridItemProps[];\r\n  targetHeight: number;\r\n  scaleFactor?: number;\r\n}): [Measures[], number, number] {\r\n  const min_height = targetHeight * (1 - scaleFactor);\r\n  // const max_height = targetHeight * (1 + scaleFactor);\r\n  // const MAX_TOLERANCE = targetHeight * 1.35;\r\n\r\n  const count = items.length;\r\n  const aspectRatios = items.map((item) => item.width / item.height);\r\n\r\n  // dp[i] represents the minimum cost to arrange items[0..i-1]\r\n  const dp = new Array(count + 1).fill(Infinity);\r\n  dp[0] = 0;\r\n\r\n  // parent[i] stores the starting index of the row that ends at i\r\n  // This is used to reconstruct the layout later\r\n  const parent = new Array(count + 1).fill(0);\r\n\r\n  for (let i = 1; i <= count; i++) {\r\n    let currentAspectRatioSum = 0;\r\n\r\n    // Look back at previous items to find the best break point\r\n    for (let j = i - 1; j >= 0; j--) {\r\n      currentAspectRatioSum += aspectRatios[j];\r\n      const rowHeight = viewportWidth / currentAspectRatioSum;\r\n\r\n      // As we add more items (decreasing j), the rowHeight gets smaller.\r\n      // If it's already smaller than min_height, adding more items will only\r\n      // make it worse (shorter). So we can stop looking back.\r\n      if (rowHeight < min_height) {\r\n        // However! If this is the very first item we are checking (j === i-1),\r\n        // we must accept it, otherwise we might end up with NO valid path\r\n        // if a single panorama is naturally shorter than min_height.\r\n        if (j !== i - 1) break;\r\n      }\r\n\r\n      // If a row is too tall, the squared cost will naturally be high,\r\n      // but it will still be selectable if it's the only option.\r\n      let cost = Math.pow(rowHeight - targetHeight, 2);\r\n\r\n      // Orphan Penalty\r\n      // We generally dislike rows with only 1 item, unless that item is naturally wide.\r\n      // If the row has 1 item and it's making the row tall (> target), add a penalty.\r\n      if (i - j === 1 && rowHeight > targetHeight)\r\n        cost += Math.pow(targetHeight, 2) * 2;\r\n\r\n      // Total cost if we break the row here\r\n      // This includes the cost up to the previous item plus the cost of the current row\r\n      const totalCost = dp[j] + cost;\r\n\r\n      // Update dp and parent if we found a new minimum cost\r\n      if (totalCost < dp[i]) {\r\n        dp[i] = totalCost;\r\n        parent[i] = j;\r\n      }\r\n    }\r\n\r\n    // Fallback for safety against Infinity\r\n    if (dp[i] === Infinity) {\r\n      parent[i] = i - 1;\r\n      dp[i] = dp[i - 1] + Math.pow(targetHeight * 10, 2);\r\n    }\r\n  }\r\n\r\n  const measures: Measures[] = new Array(count);\r\n  const rows: { start: number; end: number; height: number }[] = [];\r\n\r\n  // Backtrack from the last item to finding row breaks\r\n  let curr = count;\r\n  while (curr > 0) {\r\n    const start = parent[curr];\r\n\r\n    // Recalculate the exact height for this final decided row\r\n    let rowAspectRatioSum = 0;\r\n    for (let k = start; k < curr; k++) rowAspectRatioSum += aspectRatios[k];\r\n\r\n    const exactRowHeight = viewportWidth / rowAspectRatioSum;\r\n    // if (exactRowHeight > MAX_TOLERANCE) exactRowHeight = MAX_TOLERANCE;\r\n\r\n    rows.unshift({ start, end: curr, height: exactRowHeight });\r\n    curr = start;\r\n  }\r\n\r\n  // Generate Measures\r\n  let currentTop = 0;\r\n\r\n  rows.forEach((row, rowIndex) => {\r\n    let currentLeft = 0;\r\n    const itemsInRow = row.end - row.start;\r\n\r\n    for (let k = row.start; k < row.end; k++) {\r\n      const itemWidth = aspectRatios[k] * row.height;\r\n\r\n      measures[k] = {\r\n        width: itemWidth,\r\n        height: row.height,\r\n        top: currentTop,\r\n        left: currentLeft,\r\n        index: k - row.start,\r\n        rowNo: rowIndex + 1,\r\n        totalItemsInRow: itemsInRow,\r\n      };\r\n\r\n      currentLeft += itemWidth;\r\n    }\r\n\r\n    currentTop += row.height;\r\n  });\r\n\r\n  return [measures, currentTop, rows.length];\r\n}\r\n",
      "type": "registry:file",
      "target": "components/ui/masonry/calculate-masonry-row.ts"
    },
    {
      "path": "lib/merge-refs.ts",
      "content": "import type * as React from 'react';\n\nexport function mergeRefs<T>(\n  ...refs: (React.Ref<T> | undefined)[]\n): React.RefCallback<T> {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref) {\n        ref.current = value;\n      }\n    });\n  };\n}\n",
      "type": "registry:lib",
      "target": "lib/merge-refs.ts"
    }
  ],
  "type": "registry:component"
}